<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e1e2e; }
        ::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #585b70; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e2e;
            color: #cdd6f4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 5px;
        }
        #status {
            padding: 3px 8px;
            margin-top: 5px;
            border-radius: 3px;
            font-size: 12px;
            background: #45475a;
            color: #cdd6f4;
        }
        #messages {
            flex: 1;
            overflow-y: auto;
            border: 2px solid #45475a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 5px;
            background: #1e1e2e;
        }
        .message { margin-bottom: 8px; padding: 6px 10px; border-radius: 5px; }
        .user { background: #89b4fa; color: #1e1e2e; }
        .assistant { background: transparent; }
        .tool { background: #313244; font-size: 0.9em; color: #f9e2af; }
        .error { background: #f38ba8; color: #1e1e2e; }
        .reasoning { background: transparent; color: #6c7086; font-style: italic; }
        .system { background: transparent; color: #6c7086; font-size: 0.9em }
        .message.assistant p { margin: 0 0 8px 0; }
        .message.assistant p:last-child { margin-bottom: 0; }
        .message.assistant code { background: #313244; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
        .message.assistant pre { background: #313244; padding: 10px; border-radius: 5px; overflow-x: auto; }
        .message.assistant pre code { background: none; padding: 0; }
        .message.assistant ul, .message.assistant ol { margin: 0 0 8px 0; padding-left: 20px; }
        #input-area {
            display: flex;
            gap: 10px;
            padding: 8px;
            border: 2px solid #45475a;
            border-radius: 8px;
            background: #1e1e2e;
        }
        #input-area:focus-within {
            border-color: #89d4fa;
        }
        #prompt {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: #cdd6f4;
            font-size: 16px;
        }
        #prompt:focus { outline: none; }
        #prompt::placeholder { color: #6c7086; }
        #send {
            padding: 10px 20px;
            background: #45475a;
            border: none;
            border-radius: 5px;
            color: #cdd6f4;
            font-weight: bold;
            cursor: pointer;
        }
        #send:hover { background: #585b70; }
        pre { white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <div id="messages"></div>
    <div id="input-area">
        <input type="text" id="prompt" placeholder="Enter your prompt..." autocomplete="off">
        <button id="send">Send</button>
    </div>
    <div id="status">Context: 0 | Total: 0</div>

    <script>
        const messages = document.getElementById('messages');
        const prompt = document.getElementById('prompt');
        const send = document.getElementById('send');
        const status = document.getElementById('status');

        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = protocol + '//' + location.host + '/ws';
        let ws = null;

        let buffer = [];
        let currentTextValue = '';
        let currentTextElement = null;
        let currentReasoningValue = '';
        let currentReasoningElement = null;

        function connect() {
            ws = new WebSocket(wsUrl);

            ws.onclose = () => {
                setTimeout(connect, 3000);
            };

            ws.onmessage = (event) => {
                if (event.data instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const bytes = new Uint8Array(reader.result);
                        buffer.push(...bytes);
                        processBuffer();
                    };
                    reader.readAsArrayBuffer(event.data);
                } else {
                    addMessage('system', event.data);
                }
            };
        }

        function processBuffer() {
            while (buffer.length >= 5) {
                const tag = String.fromCharCode(buffer[0]);
                const length = new DataView(new Uint8Array(buffer.slice(1, 5)).buffer).getUint32(0, false);

                if (buffer.length < 5 + length) {
                    break;
                }

                const value = new TextDecoder().decode(new Uint8Array(buffer.slice(5, 5 + length)));
                buffer = buffer.slice(5 + length);

                handleTLV(tag, value);
            }
        }

        function handleTLV(tag, value) {
            if (tag === 'T') {
                currentTextValue += value;
                if (currentTextElement) {
                    updateMessageContent(currentTextElement, 'assistant', currentTextValue);
                } else {
                    currentTextElement = addMessageElement('assistant', currentTextValue);
                }
            } else if (tag === 'R') {
                currentReasoningValue += value;
                if (currentReasoningElement) {
                    updateMessageContent(currentReasoningElement, 'reasoning', currentReasoningValue);
                } else {
                    currentReasoningElement = addMessageElement('reasoning', currentReasoningValue);
                }
            } else if (tag === 't') {
                flushCurrentText();
                addMessage('tool', value);
            } else if (tag === 'E') {
                flushCurrentText();
                addMessage('error', value);
            } else if (tag === 'S') {
                flushCurrentText();
                addMessage('system', value);
            } else if (tag === 'P') {
                // Format: "prompt" (context/total sent separately via 'U')
                // Just show user message in dialog, status updated via periodic 'U'
                addMessage('user', value);
            } else if (tag === 'U') {
                // Format: "context=X|total=Y" - periodic status update
                const parts = value.split('|');
                let statusText = '';
                for (const part of parts) {
                    if (part.startsWith('context=')) {
                        statusText += ' | ' + part.replace('context=', 'Context: ');
                    } else if (part.startsWith('total=')) {
                        statusText += ' | ' + part.replace('total=', 'Total: ');
                    }
                }
                if (statusText) {
                    status.textContent = statusText.substring(3);
                }
            } else if (tag === 'G') {
                flushCurrentText();
                currentTextValue += '\n';
                if (currentTextElement) {
                    updateMessageContent(currentTextElement, 'assistant', currentTextValue);
                }
            }
        }

        function flushCurrentText() {
            if (currentTextElement && currentTextValue) {
                updateMessageContent(currentTextElement, 'assistant', currentTextValue);
            }
            if (currentReasoningElement && currentReasoningValue) {
                updateMessageContent(currentReasoningElement, 'reasoning', currentReasoningValue);
            }
            currentTextValue = '';
            currentTextElement = null;
            currentReasoningValue = '';
            currentReasoningElement = null;
        }

        function addMessageElement(type, text) {
            const div = document.createElement('div');
            div.className = 'message ' + type;
            if (type === 'tool') {
                div.innerHTML = '<pre>' + escapeHtml(text) + '</pre>';
            } else if (type === 'assistant' || type === 'reasoning') {
                div.innerHTML = marked.parse(text);
            } else {
                div.textContent = text;
            }
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
            return div;
        }

        function updateMessageContent(element, type, text) {
            if (type === 'tool') {
                element.innerHTML = '<pre>' + escapeHtml(text) + '</pre>';
            } else if (type === 'assistant' || type === 'reasoning') {
                element.innerHTML = marked.parse(text);
            } else {
                element.textContent = text;
            }
            messages.scrollTop = messages.scrollHeight;
        }

        function addMessage(type, text) {
            flushCurrentText();
            addMessageElement(type, text);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function sendMessage() {
            const text = prompt.value.trim();
            if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;

            // Encode as TLV with TagUserText ('A')
            const tag = 'A'.charCodeAt(0);
            const encoder = new TextEncoder();
            const valueBytes = encoder.encode(text);
            const length = valueBytes.length;

            // Build TLV message: tag (1) + length (4 big-endian) + value
            const message = new Uint8Array(5 + length);
            message[0] = tag;
            message[1] = (length >> 24) & 0xff;
            message[2] = (length >> 16) & 0xff;
            message[3] = (length >> 8) & 0xff;
            message[4] = length & 0xff;
            message.set(valueBytes, 5);

            ws.send(message);
            prompt.value = '';
        }

        send.addEventListener('click', sendMessage);
        prompt.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        prompt.focus();
        connect();
    </script>
</body>
</html>
