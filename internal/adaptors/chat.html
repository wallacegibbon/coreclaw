<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e1e2e; }
        ::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #585b70; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e2e;
            color: #cdd6f4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 5px;
        }
        #status {
            padding: 3px 8px;
            margin-top: 5px;
            border-radius: 3px;
            font-size: 12px;
            background: #45475a;
            color: #cdd6f4;
        }
        #connection {
            font-size: 11px;
            margin-bottom: 5px;
        }
        #connection.connected { color: #a6e3a1; }
        #connection.connecting { color: #f9e2af; }
        #connection.disconnected { color: #f38ba8; }
        #messages {
            flex: 1;
            overflow-y: auto;
            border: 2px solid #45475a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 5px;
            background: #1e1e2e;
        }
        .message { margin-bottom: 8px; padding: 6px 10px; border-radius: 5px; }
        .user { background: #89b4fa; color: #1e1e2e; }
        .assistant { background: transparent; }
        .tool { background: #313244; font-size: 0.9em; color: #f9e2af; }
        .error { background: #f38ba8; color: #1e1e2e; }
        .reasoning { background: transparent; color: #6c7086; font-style: italic; }
        .system { background: transparent; color: #6c7086; font-size: 0.9em }
        .message.assistant p { margin: 0 0 8px 0; }
        .message.assistant p:last-child { margin-bottom: 0; }
        .message.assistant code { background: #313244; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
        .message.assistant pre { background: #313244; padding: 10px; border-radius: 5px; overflow-x: auto; }
        .message.assistant pre code { background: none; padding: 0; }
        .message.assistant ul, .message.assistant ol { margin: 0 0 8px 0; padding-left: 20px; }
        #input-area {
            display: flex;
            gap: 10px;
            padding: 8px;
            border: 2px solid #45475a;
            border-radius: 8px;
            background: #1e1e2e;
        }
        #input-area:focus-within {
            border-color: #89d4fa;
        }
        #input-area.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        #prompt {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: #cdd6f4;
            font-size: 16px;
        }
        #prompt:focus { outline: none; }
        #prompt::placeholder { color: #6c7086; }
        #send {
            padding: 10px 20px;
            background: #45475a;
            border: none;
            border-radius: 5px;
            color: #cdd6f4;
            font-weight: bold;
            cursor: pointer;
        }
        #send:hover { background: #585b70; }
        pre { white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <div id="connection">Connecting...</div>
    <div id="messages"></div>
    <div id="input-area" class="disabled">
        <input type="text" id="prompt" placeholder="Enter your prompt..." autocomplete="off" disabled>
        <button id="send" disabled>Send</button>
    </div>
    <div id="status">Context: 0 | Total: 0</div>

    <script>
        const messages = document.getElementById('messages');
        const prompt = document.getElementById('prompt');
        const send = document.getElementById('send');
        const status = document.getElementById('status');
        const connection = document.getElementById('connection');
        const inputArea = document.getElementById('input-area');

        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = protocol + '//' + location.host + '/ws';
        let ws = null;
        let reconnectTimeout = null;

        let buffer = [];
        let currentTextValue = '';
        let currentTextElement = null;
        let currentReasoningValue = '';
        let currentReasoningElement = null;

        // TLV encoding helper
        function encodeTLV(tag, text) {
            const encoder = new TextEncoder();
            const valueBytes = encoder.encode(text);
            const length = valueBytes.length;
            const message = new Uint8Array(5 + length);
            message[0] = tag.charCodeAt(0);
            message[1] = (length >> 24) & 0xff;
            message[2] = (length >> 16) & 0xff;
            message[3] = (length >> 8) & 0xff;
            message[4] = length & 0xff;
            message.set(valueBytes, 5);
            return message;
        }

        // Send TLV message
        function sendTLV(tag, text) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            try {
                ws.send(encodeTLV(tag, text));
            } catch (e) {
                console.error('Failed to send:', e);
            }
        }

        function setConnectionState(state) {
            connection.className = state;
            if (state === 'connected') {
                connection.textContent = 'Connected';
                inputArea.classList.remove('disabled');
                prompt.disabled = false;
                send.disabled = false;
            } else if (state === 'connecting') {
                connection.textContent = 'Connecting...';
                inputArea.classList.add('disabled');
                prompt.disabled = true;
                send.disabled = true;
            } else {
                connection.textContent = 'Disconnected - Reconnecting...';
                inputArea.classList.add('disabled');
                prompt.disabled = true;
                send.disabled = true;
            }
        }

        function connect() {
            setConnectionState('connecting');

            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                setConnectionState('connected');
                prompt.focus();
            };

            ws.onclose = () => {
                setConnectionState('disconnected');
                reconnectTimeout = setTimeout(connect, 3000);
            };

            ws.onerror = () => {
                // Error handling is done via onclose
            };

            ws.onmessage = (event) => {
                if (event.data instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        buffer.push(...new Uint8Array(reader.result));
                        processBuffer();
                    };
                    reader.readAsArrayBuffer(event.data);
                } else {
                    addMessage('system', event.data);
                }
            };
        }

        function processBuffer() {
            while (buffer.length >= 5) {
                const tag = String.fromCharCode(buffer[0]);
                const length = new DataView(new Uint8Array(buffer.slice(1, 5)).buffer).getUint32(0, false);

                if (buffer.length < 5 + length) {
                    break;
                }

                const value = new TextDecoder().decode(new Uint8Array(buffer.slice(5, 5 + length)));
                buffer = buffer.slice(5 + length);

                handleTLV(tag, value);
            }
        }

        function handleTLV(tag, value) {
            if (tag === 'B') {
                currentTextValue += value;
                if (currentTextElement) {
                    updateMessageContent(currentTextElement, 'assistant', currentTextValue);
                } else {
                    currentTextElement = addMessageElement('assistant', currentTextValue);
                }
            } else if (tag === 'C') {
                currentReasoningValue += value;
                if (currentReasoningElement) {
                    updateMessageContent(currentReasoningElement, 'reasoning', currentReasoningValue);
                } else {
                    currentReasoningElement = addMessageElement('reasoning', currentReasoningValue);
                }
            } else if (tag === 'D') {
                flushCurrentText();
                addMessage('tool', value);
            } else if (tag === 'E') {
                flushCurrentText();
                addMessage('error', value);
            } else if (tag === 'N') {
                flushCurrentText();
                addMessage('system', value);
            } else if (tag === 'S') {
                flushCurrentText();
                try {
                    const systemInfo = JSON.parse(value);
                    let statusText = '';
                    if (systemInfo.queue !== undefined && systemInfo.queue > 0) {
                        statusText += 'Queue: <span style="color: #f38ba8; font-weight: bold;">' + systemInfo.queue + '</span> | ';
                    }
                    if (systemInfo.context !== undefined) {
                        statusText += 'Context: ' + systemInfo.context + ' | ';
                    }
                    if (systemInfo.total !== undefined) {
                        statusText += 'Total: ' + systemInfo.total;
                    }
                    if (statusText) {
                        // Remove trailing " | " if present
                        statusText = statusText.replace(/ \s*\|\s*$/, '');
                        status.innerHTML = statusText;
                    }
                } catch (e) {
                    // Not JSON, display as plain system message
                    addMessage('system', value);
                }
            } else if (tag === 'P') {
                addMessage('user', value);
            } else if (tag === 'G') {
                flushCurrentText();
                currentTextValue += '\n';
                if (currentTextElement) {
                    updateMessageContent(currentTextElement, 'assistant', currentTextValue);
                }
            }
        }

        function flushCurrentText() {
            if (currentTextElement && currentTextValue) {
                updateMessageContent(currentTextElement, 'assistant', currentTextValue);
            }
            if (currentReasoningElement && currentReasoningValue) {
                updateMessageContent(currentReasoningElement, 'reasoning', currentReasoningValue);
            }
            currentTextValue = '';
            currentTextElement = null;
            currentReasoningValue = '';
            currentReasoningElement = null;
        }

        function addMessageElement(type, text) {
            const div = document.createElement('div');
            div.className = 'message ' + type;
            if (type === 'tool') {
                div.innerHTML = '<pre>' + escapeHtml(text) + '</pre>';
            } else if (type === 'assistant' || type === 'reasoning') {
                div.innerHTML = marked.parse(text);
            } else {
                div.textContent = text;
            }
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
            return div;
        }

        function updateMessageContent(element, type, text) {
            if (type === 'tool') {
                element.innerHTML = '<pre>' + escapeHtml(text) + '</pre>';
            } else if (type === 'assistant' || type === 'reasoning') {
                element.innerHTML = marked.parse(text);
            } else {
                element.textContent = text;
            }
            messages.scrollTop = messages.scrollHeight;
        }

        function addMessage(type, text) {
            flushCurrentText();
            addMessageElement(type, text);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function sendMessage() {
            const text = prompt.value.trim();
            if (!text) return;
            sendTLV('A', text);
            prompt.value = '';
        }

        function sendCancelCommand() {
            sendTLV('A', '/cancel');
        }

        send.addEventListener('click', sendMessage);
        prompt.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        prompt.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                sendCancelCommand();
            }
        });

        prompt.focus();
        connect();
    </script>
</body>
</html>
